# High Performance Memory Pool

一个基于 C++11 实现的高性能内存池，专为高频分配/释放固定大小对象的场景（如游戏中的子弹、粒子系统）设计。

**注意本项目只包含源代码，你需要自行编译，提供的编译脚本需要保证你拥有正确的环境变量使得我提供的build脚本可以识别到你的编译器，这样直接运行脚本即可实现编译项目
推荐使用VSCode本项目已经实现VSCode调试兼容，默认使用内置终端，也可以自行修改为外部终端即黑框**

## 项目结构

```
Memory_Pool/
├── include/
│   └── MemoryPool.hpp   # 核心实现：内存池模板类、页管理、分配器
├── src/
│   └── main.cpp         # 仿真程序：多线程模拟、命令行交互
├── build.bat            # Windows 构建脚本
├── Makefile             # 通用构建脚本
└── README.md            # 项目文档
```

## 核心特性与优化策略

### 1. 核心架构：分页管理 (Paging)

- **原理**：不直接向操作系统申请零散的小内存，而是以 **Page (页)** 为单位申请大块内存（如 1024 个对象一块）。
- **优势**：减少系统调用 (`malloc`/`new`) 的开销，降低内存碎片。
- **实现**：`std::vector<Page*> pages_` 管理所有内存页，支持动态扩容。

### 2. 极致性能：线程局部缓存 (TLAB)

- **痛点**：多线程环境下，全局唯一的内存池会成为锁竞争的瓶颈。
- **优化**：引入 **Thread-Local Allocation Buffer (TLAB)**。
  - **分配**：每个线程维护一个私有的 `FreeList`，分配时不加锁。仅当私有缓存耗尽时，才加锁从全局池“批发”一批节点。
  - **释放**：释放时优先还会私有缓存。仅当缓存过大时，才加锁批量归还给全局池。
- **效果**：将 99% 的操作转化为无锁的指针操作，极大地提升了并发吞吐量。

### 3. 使用便捷：侵入式链表 (Intrusive List)

- **原理**：利用空闲对象的内存空间存储指向下一个空闲对象的指针 (`FreeNode`)。
- **优势**：不需要额外的内存来维护空闲链表，空间利用率高。

### 4. 健壮性：自动收缩 (GC) 与 自动对齐

- **GC 机制**：结合引用计数与二分查找，识别完全空闲的 Page 并返还给操作系统。
  - **自适应**：基于“强化学习”思想，通过长期峰值监测 (`long_term_peak_`) 和施密特触发器原理，智能决定何时缩容，避免频繁内存抖动。
- **内存对齐**：封装 `AlignedAllocator`，自动处理不同平台 (Windows/POSIX) 的内存对齐要求，确保证 SIMD 指令集兼容性。

## 快速开始

### 环境配置

**编译器路径设置（重要）**：

- 添加你的g++编译器路径，本项目使用c++11所以你不会下载新版本如c++20这样的编译器的话可以直接去下一个devc++然后在里面搜g++，把前面的路径设置为系统变量即可，如果还是不会就问copilot开agent模式帮你设置好

### 构建方式

项目提供两种构建方式：

#### 方式一：脚本编译（推荐用于快速构建）

Windows (MinGW):

```cmd
# 使用Makefile
make

# 或直接运行构建脚本
build.bat
```

#### 方式二：VSCode调试（推荐用于代码调试）

项目已配置完整的VSCode调试环境：

1. 打开项目根目录
2. 按F5开始调试
3. 在关键代码行设置断点（点击左侧红点）
4. 使用调试视图查看变量和调用堆栈

**调试支持的功能**：

- **断点调试**：在任意代码行设置断点
- **变量查看**：实时查看内存、指针、对象状态
- **调用堆栈**：追踪函数调用关系
- **单步调试**：步入(F11)、步过(F10)、步出(Shift+F11)

**推荐调试位置**：

- `main()` 函数入口
- `MemoryPool::allocate()` 内存分配
- `MemoryPool::deallocate()` 内存释放
- 多线程测试代码

### 运行仿真

```cmd
MemoryPool.exe
```

### 交互指令

程序启动后进入命令行交互模式：

- `<ThreadID> <Count>`: 指定线程发射多少发子弹。 例如 `1 10000` 表示线程 1 发射 10000 发。
- `clear`: 强制回收所有活跃子弹，并通知所有线程清空本地缓存。
- `status`: 查看当前内存池的详细统计信息。
- `exit`: 退出程序。

## 常见问题

**Q: 为什么 clear 后 Pool Used 不为 0？**
A: 这是 TLAB 的特性。为了性能，每个线程会保留一部分空闲节点在本地缓存中。我们在 `clear` 命令中实现了广播机制，会通知所有工作线程执行 `flush`，但由于线程异步执行，统计数据可能会有短暂延迟。再次执行 `status` 即可看到归零。
